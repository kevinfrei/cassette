// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from www/Shared/Definitions.ts by running 'crow-idl
// ...' If you need to change this file, edit www/Shared/Definitions.ts and run
// the crow-idl command again. Or, if you need to change the generation process,
// put up a pull-request to https://github.com/kevinfrei/crow-idl
// DO NOT EDIT THIS FILE DIRECTLY!!!

// Generated by cassette v0.1.0
#pragma once

#ifndef CPP_INCLUDE_COMMONTYPES_HPP
#define CPP_INCLUDE_COMMONTYPES_HPP

#include <cstdint>
#include <map>
#include <optional>
#include <string_view>
#include <unordered_map>
#include <utility>
#include <vector>

#include <crow/json.h>

// TODO: Inline this?
#include "json_pickling.hpp"

namespace Shared {

template <typename T>
constexpr std::optional<T> from_string(const std::string_view& str);

#pragma region string enum Keys

enum class Keys {
  AddFileLocation,
  Albums,
  Artists,
  Backward10s,
  Find,
  Forward10s,
  NextTrack,
  NowPlaying,
  Play,
  Playlists,
  PreviousTrack,
  Repeat,
  SavePlaylist,
  Settings,
  Shuffle,
  Songs,
  ToggleMiniPlayer,
  Tools
};

inline constexpr bool is_valid(Keys _value) {
  switch (_value) {
    case Keys::AddFileLocation:
    case Keys::Albums:
    case Keys::Artists:
    case Keys::Backward10s:
    case Keys::Find:
    case Keys::Forward10s:
    case Keys::NextTrack:
    case Keys::NowPlaying:
    case Keys::Play:
    case Keys::Playlists:
    case Keys::PreviousTrack:
    case Keys::Repeat:
    case Keys::SavePlaylist:
    case Keys::Settings:
    case Keys::Shuffle:
    case Keys::Songs:
    case Keys::ToggleMiniPlayer:
    case Keys::Tools:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(Keys _value) {
  switch (_value) {
    case Keys::AddFileLocation:
      return "O";
    case Keys::Albums:
      return "2";
    case Keys::Artists:
      return "3";
    case Keys::Backward10s:
      return "[";
    case Keys::Find:
      return "F";
    case Keys::Forward10s:
      return "]";
    case Keys::NextTrack:
      return "Right";
    case Keys::NowPlaying:
      return "1";
    case Keys::Play:
      return "P";
    case Keys::Playlists:
      return "5";
    case Keys::PreviousTrack:
      return "Left";
    case Keys::Repeat:
      return "T";
    case Keys::SavePlaylist:
      return "S";
    case Keys::Settings:
      return ",";
    case Keys::Shuffle:
      return "R";
    case Keys::Songs:
      return "4";
    case Keys::ToggleMiniPlayer:
      return "9";
    case Keys::Tools:
      return "L";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<Keys> from_string<Keys>(
    const std::string_view& str) {
  if (str == "O")
    return Keys::AddFileLocation;
  if (str == "2")
    return Keys::Albums;
  if (str == "3")
    return Keys::Artists;
  if (str == "[")
    return Keys::Backward10s;
  if (str == "F")
    return Keys::Find;
  if (str == "]")
    return Keys::Forward10s;
  if (str == "Right")
    return Keys::NextTrack;
  if (str == "1")
    return Keys::NowPlaying;
  if (str == "P")
    return Keys::Play;
  if (str == "5")
    return Keys::Playlists;
  if (str == "Left")
    return Keys::PreviousTrack;
  if (str == "T")
    return Keys::Repeat;
  if (str == "S")
    return Keys::SavePlaylist;
  if (str == ",")
    return Keys::Settings;
  if (str == "R")
    return Keys::Shuffle;
  if (str == "4")
    return Keys::Songs;
  if (str == "9")
    return Keys::ToggleMiniPlayer;
  if (str == "L")
    return Keys::Tools;
  return std::nullopt;
}

#pragma endregion string enum Keys

#pragma region string enum StrId

enum class StrId {
  Mono,
  Stereo,
  Quadrophonic,
  Channels,
  BitDepth,
  FilePath,
  Duration,
  MDHeaderField,
  MDHeaderValue,
  FilesSelected,
  RawMetadata,
  ChooseCoverArt,
  ImageName,
  ErrNotSingleAndNotMultiple,
  ErrSingleAndMultiple,
  Title,
  ArtistTooltip,
  Artists,
  Album,
  Year,
  TrackNum,
  DiskNum,
  DiskName,
  Compilation,
  Soundtrack,
  AdditionalArtists,
  VariationsTooltip,
  Variations,
  AlbumCover,
  ChooseFile,
  FromClipboard,
  ViewNowPlaying,
  ViewAlbums,
  ViewArtists,
  ViewSongs,
  ViewPlaylists,
  ViewSettings,
  ViewTools,
  ImportFiles
};

inline constexpr bool is_valid(StrId _value) {
  switch (_value) {
    case StrId::Mono:
    case StrId::Stereo:
    case StrId::Quadrophonic:
    case StrId::Channels:
    case StrId::BitDepth:
    case StrId::FilePath:
    case StrId::Duration:
    case StrId::MDHeaderField:
    case StrId::MDHeaderValue:
    case StrId::FilesSelected:
    case StrId::RawMetadata:
    case StrId::ChooseCoverArt:
    case StrId::ImageName:
    case StrId::ErrNotSingleAndNotMultiple:
    case StrId::ErrSingleAndMultiple:
    case StrId::Title:
    case StrId::ArtistTooltip:
    case StrId::Artists:
    case StrId::Album:
    case StrId::Year:
    case StrId::TrackNum:
    case StrId::DiskNum:
    case StrId::DiskName:
    case StrId::Compilation:
    case StrId::Soundtrack:
    case StrId::AdditionalArtists:
    case StrId::VariationsTooltip:
    case StrId::Variations:
    case StrId::AlbumCover:
    case StrId::ChooseFile:
    case StrId::FromClipboard:
    case StrId::ViewNowPlaying:
    case StrId::ViewAlbums:
    case StrId::ViewArtists:
    case StrId::ViewSongs:
    case StrId::ViewPlaylists:
    case StrId::ViewSettings:
    case StrId::ViewTools:
    case StrId::ImportFiles:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(StrId _value) {
  switch (_value) {
    case StrId::Mono:
      return "mono";
    case StrId::Stereo:
      return "stereo";
    case StrId::Quadrophonic:
      return "quadrophonic";
    case StrId::Channels:
      return " channels";
    case StrId::BitDepth:
      return "bit";
    case StrId::FilePath:
      return "File Path";
    case StrId::Duration:
      return "Duration:";
    case StrId::MDHeaderField:
      return "Field";
    case StrId::MDHeaderValue:
      return "Value";
    case StrId::FilesSelected:
      return "Files Selected";
    case StrId::RawMetadata:
      return "Raw Metadata";
    case StrId::ChooseCoverArt:
      return "Select Cover Art Image";
    case StrId::ImageName:
      return "Images";
    case StrId::ErrNotSingleAndNotMultiple:
      return "Not Single and not Multiple (This is a bug!)";
    case StrId::ErrSingleAndMultiple:
      return "Both Single and Multiple (This is a bug!)";
    case StrId::Title:
      return "Title";
    case StrId::ArtistTooltip:
      return "Multiple artists are specified like this: 'Artist 1, Artist 2 & "
             "Artist 3'";
    case StrId::Artists:
      return "Artist(s)";
    case StrId::Album:
      return "Album";
    case StrId::Year:
      return "Year";
    case StrId::TrackNum:
      return "Track #";
    case StrId::DiskNum:
      return "Disk #";
    case StrId::DiskName:
      return "Disk Name";
    case StrId::Compilation:
      return "Compilation";
    case StrId::Soundtrack:
      return "Soundtrack";
    case StrId::AdditionalArtists:
      return "Additional Artist(s)";
    case StrId::VariationsTooltip:
      return "Separate vartiations with a semicolon";
    case StrId::Variations:
      return "Variation(s)";
    case StrId::AlbumCover:
      return "Album Cover";
    case StrId::ChooseFile:
      return "Choose File...";
    case StrId::FromClipboard:
      return "From Clipboard";
    case StrId::ViewNowPlaying:
      return "Now Playing";
    case StrId::ViewAlbums:
      return "Albums";
    case StrId::ViewArtists:
      return "Artists";
    case StrId::ViewSongs:
      return "All Songs";
    case StrId::ViewPlaylists:
      return "Playlists";
    case StrId::ViewSettings:
      return "Settings";
    case StrId::ViewTools:
      return "Tools";
    case StrId::ImportFiles:
      return "Import Files...";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<StrId> from_string<StrId>(
    const std::string_view& str) {
  if (str == "mono")
    return StrId::Mono;
  if (str == "stereo")
    return StrId::Stereo;
  if (str == "quadrophonic")
    return StrId::Quadrophonic;
  if (str == " channels")
    return StrId::Channels;
  if (str == "bit")
    return StrId::BitDepth;
  if (str == "File Path")
    return StrId::FilePath;
  if (str == "Duration:")
    return StrId::Duration;
  if (str == "Field")
    return StrId::MDHeaderField;
  if (str == "Value")
    return StrId::MDHeaderValue;
  if (str == "Files Selected")
    return StrId::FilesSelected;
  if (str == "Raw Metadata")
    return StrId::RawMetadata;
  if (str == "Select Cover Art Image")
    return StrId::ChooseCoverArt;
  if (str == "Images")
    return StrId::ImageName;
  if (str == "Not Single and not Multiple (This is a bug!)")
    return StrId::ErrNotSingleAndNotMultiple;
  if (str == "Both Single and Multiple (This is a bug!)")
    return StrId::ErrSingleAndMultiple;
  if (str == "Title")
    return StrId::Title;
  if (str ==
      "Multiple artists are specified like this: 'Artist 1, Artist 2 & Artist "
      "3'")
    return StrId::ArtistTooltip;
  if (str == "Artist(s)")
    return StrId::Artists;
  if (str == "Album")
    return StrId::Album;
  if (str == "Year")
    return StrId::Year;
  if (str == "Track #")
    return StrId::TrackNum;
  if (str == "Disk #")
    return StrId::DiskNum;
  if (str == "Disk Name")
    return StrId::DiskName;
  if (str == "Compilation")
    return StrId::Compilation;
  if (str == "Soundtrack")
    return StrId::Soundtrack;
  if (str == "Additional Artist(s)")
    return StrId::AdditionalArtists;
  if (str == "Separate vartiations with a semicolon")
    return StrId::VariationsTooltip;
  if (str == "Variation(s)")
    return StrId::Variations;
  if (str == "Album Cover")
    return StrId::AlbumCover;
  if (str == "Choose File...")
    return StrId::ChooseFile;
  if (str == "From Clipboard")
    return StrId::FromClipboard;
  if (str == "Now Playing")
    return StrId::ViewNowPlaying;
  if (str == "Albums")
    return StrId::ViewAlbums;
  if (str == "Artists")
    return StrId::ViewArtists;
  if (str == "All Songs")
    return StrId::ViewSongs;
  if (str == "Playlists")
    return StrId::ViewPlaylists;
  if (str == "Settings")
    return StrId::ViewSettings;
  if (str == "Tools")
    return StrId::ViewTools;
  if (str == "Import Files...")
    return StrId::ImportFiles;
  return std::nullopt;
}

#pragma endregion string enum StrId

#pragma region linear enum CurrentView
enum class CurrentView {
  disabled = -1,
  none = 0,
  recent = 1,
  albums = 2,
  artists = 3,
  songs = 4,
  playlists = 5,
  now_playing = 6,
  settings = 7,
  search = 8,
  tools = 9,
};

inline constexpr bool is_valid(CurrentView _value) {
  switch (_value) {
    case CurrentView::disabled:
    case CurrentView::none:
    case CurrentView::recent:
    case CurrentView::albums:
    case CurrentView::artists:
    case CurrentView::songs:
    case CurrentView::playlists:
    case CurrentView::now_playing:
    case CurrentView::settings:
    case CurrentView::search:
    case CurrentView::tools:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(CurrentView _value) {
  switch (_value) {
    case CurrentView::disabled:
      return "disabled";
    case CurrentView::none:
      return "none";
    case CurrentView::recent:
      return "recent";
    case CurrentView::albums:
      return "albums";
    case CurrentView::artists:
      return "artists";
    case CurrentView::songs:
      return "songs";
    case CurrentView::playlists:
      return "playlists";
    case CurrentView::now_playing:
      return "now_playing";
    case CurrentView::settings:
      return "settings";
    case CurrentView::search:
      return "search";
    case CurrentView::tools:
      return "tools";
    default:
      return "<unknown>";
  }
}

#pragma endregion linear enum CurrentView

#pragma region linear enum IpcCall
enum class IpcCall : std::uint8_t {
  Unknown = 0,
  ReadFromStorage = 1,
  WriteToStorage = 2,
  DeleteFromStorage = 3,
  AsyncData = 4,
  IsDev = 5,
  ClearHates = 6,
  ClearLikes = 7,
  ClearLocalOverrides = 8,
  DeletePlaylist = 9,
  FlushImageCache = 10,
  FlushMetadataCache = 11,
  GetHates = 12,
  GetLikes = 13,
  GetMediaInfo = 14,
  GetMusicDatabase = 15,
  GetPlaylists = 16,
  LoadPlaylist = 17,
  MenuAction = 18,
  RenamePlaylist = 19,
  SavePlaylist = 20,
  Search = 21,
  SetHates = 22,
  SetLikes = 23,
  SetMediaInfo = 24,
  SetPlaylists = 25,
  SetSaveMenu = 26,
  ShowFile = 27,
  ShowLocFromKey = 28,
  ShowMenu = 29,
  SubstrSearch = 30,
  TranscodingBegin = 31,
  UploadImage = 32,
  MinimizeWindow = 33,
  MaximizeWindow = 34,
  RestoreWindow = 35,
  CloseWindow = 36,
  GetPicUri = 37,
  GetIgnoreList = 38,
  AddIgnoreItem = 39,
  RemoveIgnoreItem = 40,
  PushIgnoreList = 41,
  IgnoreListId = 42,
  ShowOpenDialog = 43,
};

inline constexpr bool is_valid(IpcCall _value) {
  switch (_value) {
    case IpcCall::Unknown:
    case IpcCall::ReadFromStorage:
    case IpcCall::WriteToStorage:
    case IpcCall::DeleteFromStorage:
    case IpcCall::AsyncData:
    case IpcCall::IsDev:
    case IpcCall::ClearHates:
    case IpcCall::ClearLikes:
    case IpcCall::ClearLocalOverrides:
    case IpcCall::DeletePlaylist:
    case IpcCall::FlushImageCache:
    case IpcCall::FlushMetadataCache:
    case IpcCall::GetHates:
    case IpcCall::GetLikes:
    case IpcCall::GetMediaInfo:
    case IpcCall::GetMusicDatabase:
    case IpcCall::GetPlaylists:
    case IpcCall::LoadPlaylist:
    case IpcCall::MenuAction:
    case IpcCall::RenamePlaylist:
    case IpcCall::SavePlaylist:
    case IpcCall::Search:
    case IpcCall::SetHates:
    case IpcCall::SetLikes:
    case IpcCall::SetMediaInfo:
    case IpcCall::SetPlaylists:
    case IpcCall::SetSaveMenu:
    case IpcCall::ShowFile:
    case IpcCall::ShowLocFromKey:
    case IpcCall::ShowMenu:
    case IpcCall::SubstrSearch:
    case IpcCall::TranscodingBegin:
    case IpcCall::UploadImage:
    case IpcCall::MinimizeWindow:
    case IpcCall::MaximizeWindow:
    case IpcCall::RestoreWindow:
    case IpcCall::CloseWindow:
    case IpcCall::GetPicUri:
    case IpcCall::GetIgnoreList:
    case IpcCall::AddIgnoreItem:
    case IpcCall::RemoveIgnoreItem:
    case IpcCall::PushIgnoreList:
    case IpcCall::IgnoreListId:
    case IpcCall::ShowOpenDialog:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(IpcCall _value) {
  switch (_value) {
    case IpcCall::Unknown:
      return "Unknown";
    case IpcCall::ReadFromStorage:
      return "ReadFromStorage";
    case IpcCall::WriteToStorage:
      return "WriteToStorage";
    case IpcCall::DeleteFromStorage:
      return "DeleteFromStorage";
    case IpcCall::AsyncData:
      return "AsyncData";
    case IpcCall::IsDev:
      return "IsDev";
    case IpcCall::ClearHates:
      return "ClearHates";
    case IpcCall::ClearLikes:
      return "ClearLikes";
    case IpcCall::ClearLocalOverrides:
      return "ClearLocalOverrides";
    case IpcCall::DeletePlaylist:
      return "DeletePlaylist";
    case IpcCall::FlushImageCache:
      return "FlushImageCache";
    case IpcCall::FlushMetadataCache:
      return "FlushMetadataCache";
    case IpcCall::GetHates:
      return "GetHates";
    case IpcCall::GetLikes:
      return "GetLikes";
    case IpcCall::GetMediaInfo:
      return "GetMediaInfo";
    case IpcCall::GetMusicDatabase:
      return "GetMusicDatabase";
    case IpcCall::GetPlaylists:
      return "GetPlaylists";
    case IpcCall::LoadPlaylist:
      return "LoadPlaylist";
    case IpcCall::MenuAction:
      return "MenuAction";
    case IpcCall::RenamePlaylist:
      return "RenamePlaylist";
    case IpcCall::SavePlaylist:
      return "SavePlaylist";
    case IpcCall::Search:
      return "Search";
    case IpcCall::SetHates:
      return "SetHates";
    case IpcCall::SetLikes:
      return "SetLikes";
    case IpcCall::SetMediaInfo:
      return "SetMediaInfo";
    case IpcCall::SetPlaylists:
      return "SetPlaylists";
    case IpcCall::SetSaveMenu:
      return "SetSaveMenu";
    case IpcCall::ShowFile:
      return "ShowFile";
    case IpcCall::ShowLocFromKey:
      return "ShowLocFromKey";
    case IpcCall::ShowMenu:
      return "ShowMenu";
    case IpcCall::SubstrSearch:
      return "SubstrSearch";
    case IpcCall::TranscodingBegin:
      return "TranscodingBegin";
    case IpcCall::UploadImage:
      return "UploadImage";
    case IpcCall::MinimizeWindow:
      return "MinimizeWindow";
    case IpcCall::MaximizeWindow:
      return "MaximizeWindow";
    case IpcCall::RestoreWindow:
      return "RestoreWindow";
    case IpcCall::CloseWindow:
      return "CloseWindow";
    case IpcCall::GetPicUri:
      return "GetPicUri";
    case IpcCall::GetIgnoreList:
      return "GetIgnoreList";
    case IpcCall::AddIgnoreItem:
      return "AddIgnoreItem";
    case IpcCall::RemoveIgnoreItem:
      return "RemoveIgnoreItem";
    case IpcCall::PushIgnoreList:
      return "PushIgnoreList";
    case IpcCall::IgnoreListId:
      return "IgnoreListId";
    case IpcCall::ShowOpenDialog:
      return "ShowOpenDialog";
    default:
      return "<unknown>";
  }
}

#pragma endregion linear enum IpcCall

#pragma region numeric enum SocketMsg
enum class SocketMsg : std::uint8_t {
  Unknown,
  TranscodingUpdate,
  ManualRescan,
  RescanInProgress,
  RescanComplete,
  MusicDBUpdate,
  ContentLoaded,
  KeepAlive
};

inline constexpr bool is_valid(SocketMsg _value) {
  switch (_value) {
    case SocketMsg::Unknown:
    case SocketMsg::TranscodingUpdate:
    case SocketMsg::ManualRescan:
    case SocketMsg::RescanInProgress:
    case SocketMsg::RescanComplete:
    case SocketMsg::MusicDBUpdate:
    case SocketMsg::ContentLoaded:
    case SocketMsg::KeepAlive:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(SocketMsg _value) {
  switch (_value) {
    case SocketMsg::Unknown:
      return "Unknown";
    case SocketMsg::TranscodingUpdate:
      return "TranscodingUpdate";
    case SocketMsg::ManualRescan:
      return "ManualRescan";
    case SocketMsg::RescanInProgress:
      return "RescanInProgress";
    case SocketMsg::RescanComplete:
      return "RescanComplete";
    case SocketMsg::MusicDBUpdate:
      return "MusicDBUpdate";
    case SocketMsg::ContentLoaded:
      return "ContentLoaded";
    case SocketMsg::KeepAlive:
      return "KeepAlive";
    default:
      return "<unknown>";
  }
}
#pragma endregion numeric enum SocketMsg

#pragma region string enum IgnoreItemType

enum class IgnoreItemType { PathRoot, PathKeyword, DirName };

inline constexpr bool is_valid(IgnoreItemType _value) {
  switch (_value) {
    case IgnoreItemType::PathRoot:
    case IgnoreItemType::PathKeyword:
    case IgnoreItemType::DirName:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(IgnoreItemType _value) {
  switch (_value) {
    case IgnoreItemType::PathRoot:
      return "path-root";
    case IgnoreItemType::PathKeyword:
      return "path-keyword";
    case IgnoreItemType::DirName:
      return "dir-name";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<IgnoreItemType> from_string<IgnoreItemType>(
    const std::string_view& str) {
  if (str == "path-root")
    return IgnoreItemType::PathRoot;
  if (str == "path-keyword")
    return IgnoreItemType::PathKeyword;
  if (str == "dir-name")
    return IgnoreItemType::DirName;
  return std::nullopt;
}

#pragma endregion string enum IgnoreItemType

struct IgnoreItemPair {
  IgnoreItemType type;
  std::string value;
};

#pragma region string enum StorageId

enum class StorageId {
  CurrentView,
  Shuffle,
  Repeat,
  CurrentIndex,
  Mute,
  Volume,
  PlaybackOrder,
  NowPlaying,
  CurrentSongList,
  Locations,
  DefaultLocation,
  OnlyPlayLikes,
  NeverPlayHates,
  FullAlbumsOnly,
  MinSongCount,
  LikedSongs,
  HatedSongs,
  SortWithArticles,
  DownloadAlbumArtwork,
  DownloadArtistArtwork,
  SaveAlbumArtworkWithMusic,
  AlbumCoverName,
  TranscodingUpdate,
  TranscodeSrcLocDir,
  TranscodeSrcLocPlaylist,
  TranscodeSrcLocArtist,
  TranscodeSrcLocAlbum,
  TranscodeDestLoc,
  TranscodeBitRate
};

inline constexpr bool is_valid(StorageId _value) {
  switch (_value) {
    case StorageId::CurrentView:
    case StorageId::Shuffle:
    case StorageId::Repeat:
    case StorageId::CurrentIndex:
    case StorageId::Mute:
    case StorageId::Volume:
    case StorageId::PlaybackOrder:
    case StorageId::NowPlaying:
    case StorageId::CurrentSongList:
    case StorageId::Locations:
    case StorageId::DefaultLocation:
    case StorageId::OnlyPlayLikes:
    case StorageId::NeverPlayHates:
    case StorageId::FullAlbumsOnly:
    case StorageId::MinSongCount:
    case StorageId::LikedSongs:
    case StorageId::HatedSongs:
    case StorageId::SortWithArticles:
    case StorageId::DownloadAlbumArtwork:
    case StorageId::DownloadArtistArtwork:
    case StorageId::SaveAlbumArtworkWithMusic:
    case StorageId::AlbumCoverName:
    case StorageId::TranscodingUpdate:
    case StorageId::TranscodeSrcLocDir:
    case StorageId::TranscodeSrcLocPlaylist:
    case StorageId::TranscodeSrcLocArtist:
    case StorageId::TranscodeSrcLocAlbum:
    case StorageId::TranscodeDestLoc:
    case StorageId::TranscodeBitRate:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(StorageId _value) {
  switch (_value) {
    case StorageId::CurrentView:
      return "currentView";
    case StorageId::Shuffle:
      return "shuffle";
    case StorageId::Repeat:
      return "repeat";
    case StorageId::CurrentIndex:
      return "currentIndex";
    case StorageId::Mute:
      return "mute";
    case StorageId::Volume:
      return "volume";
    case StorageId::PlaybackOrder:
      return "playbackOrder";
    case StorageId::NowPlaying:
      return "nowPlaying";
    case StorageId::CurrentSongList:
      return "currentSongList";
    case StorageId::Locations:
      return "locations";
    case StorageId::DefaultLocation:
      return "defaultLocation";
    case StorageId::OnlyPlayLikes:
      return "onlyPlayLikes";
    case StorageId::NeverPlayHates:
      return "neverPlayHates";
    case StorageId::FullAlbumsOnly:
      return "fullAlbumsOnly";
    case StorageId::MinSongCount:
      return "minSongCount";
    case StorageId::LikedSongs:
      return "likedSongs";
    case StorageId::HatedSongs:
      return "hatedSongs";
    case StorageId::SortWithArticles:
      return "sortWithArticles";
    case StorageId::DownloadAlbumArtwork:
      return "downloadAlbumArtwork";
    case StorageId::DownloadArtistArtwork:
      return "downloadArtistArtwork";
    case StorageId::SaveAlbumArtworkWithMusic:
      return "saveAlbumArtworkWithMusic";
    case StorageId::AlbumCoverName:
      return "albumCoverName";
    case StorageId::TranscodingUpdate:
      return "getTranscodeUpdate";
    case StorageId::TranscodeSrcLocDir:
      return "transcodeSrcLocDir";
    case StorageId::TranscodeSrcLocPlaylist:
      return "transcodeSrcLocPlaylist";
    case StorageId::TranscodeSrcLocArtist:
      return "transcodeSrcLocArtist";
    case StorageId::TranscodeSrcLocAlbum:
      return "transcodeSrcLocAlbum";
    case StorageId::TranscodeDestLoc:
      return "transcodeDestLoc";
    case StorageId::TranscodeBitRate:
      return "transcodeBitRate";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<StorageId> from_string<StorageId>(
    const std::string_view& str) {
  if (str == "currentView")
    return StorageId::CurrentView;
  if (str == "shuffle")
    return StorageId::Shuffle;
  if (str == "repeat")
    return StorageId::Repeat;
  if (str == "currentIndex")
    return StorageId::CurrentIndex;
  if (str == "mute")
    return StorageId::Mute;
  if (str == "volume")
    return StorageId::Volume;
  if (str == "playbackOrder")
    return StorageId::PlaybackOrder;
  if (str == "nowPlaying")
    return StorageId::NowPlaying;
  if (str == "currentSongList")
    return StorageId::CurrentSongList;
  if (str == "locations")
    return StorageId::Locations;
  if (str == "defaultLocation")
    return StorageId::DefaultLocation;
  if (str == "onlyPlayLikes")
    return StorageId::OnlyPlayLikes;
  if (str == "neverPlayHates")
    return StorageId::NeverPlayHates;
  if (str == "fullAlbumsOnly")
    return StorageId::FullAlbumsOnly;
  if (str == "minSongCount")
    return StorageId::MinSongCount;
  if (str == "likedSongs")
    return StorageId::LikedSongs;
  if (str == "hatedSongs")
    return StorageId::HatedSongs;
  if (str == "sortWithArticles")
    return StorageId::SortWithArticles;
  if (str == "downloadAlbumArtwork")
    return StorageId::DownloadAlbumArtwork;
  if (str == "downloadArtistArtwork")
    return StorageId::DownloadArtistArtwork;
  if (str == "saveAlbumArtworkWithMusic")
    return StorageId::SaveAlbumArtworkWithMusic;
  if (str == "albumCoverName")
    return StorageId::AlbumCoverName;
  if (str == "getTranscodeUpdate")
    return StorageId::TranscodingUpdate;
  if (str == "transcodeSrcLocDir")
    return StorageId::TranscodeSrcLocDir;
  if (str == "transcodeSrcLocPlaylist")
    return StorageId::TranscodeSrcLocPlaylist;
  if (str == "transcodeSrcLocArtist")
    return StorageId::TranscodeSrcLocArtist;
  if (str == "transcodeSrcLocAlbum")
    return StorageId::TranscodeSrcLocAlbum;
  if (str == "transcodeDestLoc")
    return StorageId::TranscodeDestLoc;
  if (str == "transcodeBitRate")
    return StorageId::TranscodeBitRate;
  return std::nullopt;
}

#pragma endregion string enum StorageId

#pragma region string enum TranscodeFormatTargetName

enum class TranscodeFormatTargetName { m4a, mp3, aac };

inline constexpr bool is_valid(TranscodeFormatTargetName _value) {
  switch (_value) {
    case TranscodeFormatTargetName::m4a:
    case TranscodeFormatTargetName::mp3:
    case TranscodeFormatTargetName::aac:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(TranscodeFormatTargetName _value) {
  switch (_value) {
    case TranscodeFormatTargetName::m4a:
      return "m4a";
    case TranscodeFormatTargetName::mp3:
      return "mp3";
    case TranscodeFormatTargetName::aac:
      return "aac";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<TranscodeFormatTargetName>
from_string<TranscodeFormatTargetName>(const std::string_view& str) {
  if (str == "m4a")
    return TranscodeFormatTargetName::m4a;
  if (str == "mp3")
    return TranscodeFormatTargetName::mp3;
  if (str == "aac")
    return TranscodeFormatTargetName::aac;
  return std::nullopt;
}

#pragma endregion string enum TranscodeFormatTargetName

#pragma region string enum TranscodeSource

enum class TranscodeSource { Playlist, Artist, Album, Disk };

inline constexpr bool is_valid(TranscodeSource _value) {
  switch (_value) {
    case TranscodeSource::Playlist:
    case TranscodeSource::Artist:
    case TranscodeSource::Album:
    case TranscodeSource::Disk:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(TranscodeSource _value) {
  switch (_value) {
    case TranscodeSource::Playlist:
      return "p";
    case TranscodeSource::Artist:
      return "r";
    case TranscodeSource::Album:
      return "l";
    case TranscodeSource::Disk:
      return "d";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<TranscodeSource> from_string<TranscodeSource>(
    const std::string_view& str) {
  if (str == "p")
    return TranscodeSource::Playlist;
  if (str == "r")
    return TranscodeSource::Artist;
  if (str == "l")
    return TranscodeSource::Album;
  if (str == "d")
    return TranscodeSource::Disk;
  return std::nullopt;
}

#pragma endregion string enum TranscodeSource

struct TranscodeSourceLocation {
  TranscodeSource type;
  std::string loc;
};

struct FileFailure {
  std::string file;
  std::string error;
};

struct TranscodeState {
  std::string curStatus;
  std::vector<std::string> filesTranscoded;
  std::int32_t filesFound;
  std::int32_t filesPending;
  std::int32_t filesUntouched;
  std::vector<FileFailure> filesFailed;
  std::vector<std::string> itemsRemoved;
};

struct TranscodeInfo {
  TranscodeSourceLocation source;
  std::string dest;
  bool artwork;
  bool mirror;
  TranscodeFormatTargetName format;
  std::uint16_t bitrate;
};
using SongKey = std::string;
using AlbumKey = std::string;
using ArtistKey = std::string;
using MediaKey = std::string;
using PlaylistName = std::string;
using Playlist = std::vector<SongKey>;

struct Song {
  SongKey key;
  std::int16_t track;
  std::string title;
  AlbumKey albumId;
  std::vector<ArtistKey> artistIds;
  std::vector<ArtistKey> secondaryIds;
  std::vector<std::string> variations;
};

struct SongWithPath : public Song {
  std::string path;
};

#pragma region string enum VAType

enum class VAType { none, va, ost };

inline constexpr bool is_valid(VAType _value) {
  switch (_value) {
    case VAType::none:
    case VAType::va:
    case VAType::ost:
      return true;
    default:
      return false;
  }
}

inline constexpr std::string_view to_string(VAType _value) {
  switch (_value) {
    case VAType::none:
      return "None";
    case VAType::va:
      return "VA";
    case VAType::ost:
      return "OST";
    default:
      return "<unknown>";
  }
}

// This is *super* simplistic, and should be optimized, cuz this is bad.
// A deeply nested switch statement would be pretty fun to generate...
template <>
inline constexpr std::optional<VAType> from_string<VAType>(
    const std::string_view& str) {
  if (str == "None")
    return VAType::none;
  if (str == "VA")
    return VAType::va;
  if (str == "OST")
    return VAType::ost;
  return std::nullopt;
}

#pragma endregion string enum VAType

struct Artist {
  ArtistKey key;
  std::string name;
  std::vector<AlbumKey> albums;
  std::vector<SongKey> songs;
};

struct Album {
  AlbumKey key;
  std::int16_t year;
  std::string title;
  VAType vatype;
  std::vector<ArtistKey> primaryArtists;
  std::vector<SongKey> songs;
  std::vector<std::string> diskNames;
};

struct MediaInfo {
  std::map<std::string, std::string> general;
  std::map<std::string, std::string> audio;
};

struct SimpleMetadata {
  std::string artist;
  std::string album;
  std::string year;
  std::string track;
  std::string title;
  std::string discNum;
  std::string discName;
  VAType compilation;
};

struct FullMetadata {
  std::string originalPath;
  std::vector<std::string> artist;
  std::string album;
  std::int16_t year;
  std::int16_t track;
  std::string title;
  VAType vaType;
  std::vector<std::string> moreArtists;
  std::vector<std::string> variations;
  std::int16_t disk;
  std::string diskName;
};

struct AudioFileRegexPattern {
  VAType compilation;
  std::string rgx;
};

struct MimeData {
  std::string type;
  std::string data;
};

struct MusicDatabase {
  std::unordered_map<ArtistKey, Artist> artists;
  std::unordered_map<AlbumKey, Album> albums;
  std::unordered_map<SongKey, Song> songs;
  std::map<std::string, Playlist> playlists;
};

struct FileFilterItem {
  std::string name;
  std::vector<std::string> extensions;
};

struct OpenDialogOptions {
  std::optional<bool> folder;
  std::optional<std::string> title;
  std::optional<std::string> defaultPath;
  std::optional<std::string> buttonLabel;
  std::optional<bool> multiSelections;
  std::optional<std::vector<FileFilterItem>> filters;
};

struct SearchResults {
  std::vector<SongKey> songs;
  std::vector<ArtistKey> artists;
  std::vector<AlbumKey> albums;
};

} // namespace Shared
#pragma region JSON serialization for string enum Keys
template <>
inline crow::json::wvalue to_json<Shared::Keys>(Shared::Keys _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::Keys> {
  static inline std::optional<Shared::Keys> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::Keys>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum Keys

#pragma region JSON serialization for string enum StrId
template <>
inline crow::json::wvalue to_json<Shared::StrId>(Shared::StrId _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::StrId> {
  static inline std::optional<Shared::StrId> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::StrId>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum StrId

#pragma region JSON serialization for string enum IgnoreItemType
template <>
inline crow::json::wvalue to_json<Shared::IgnoreItemType>(
    Shared::IgnoreItemType _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::IgnoreItemType> {
  static inline std::optional<Shared::IgnoreItemType> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::IgnoreItemType>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum IgnoreItemType

#pragma region JSON serialization for object IgnoreItemPair
template <>
struct impl_to_json<Shared::IgnoreItemPair> {
  static inline crow::json::wvalue process(
      const Shared::IgnoreItemPair& _value) {
    crow::json::wvalue _res;
    _res["type"] = to_json(_value.type);
    _res["value"] = to_json(_value.value);

    return _res;
  }
};

template <>
inline std::optional<Shared::IgnoreItemPair> from_json<Shared::IgnoreItemPair>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::IgnoreItemPair _res;

  if (!_value.has("type"))
    return std::nullopt;
  auto _type_opt_ = from_json<Shared::IgnoreItemType>(_value["type"]);
  if (!_type_opt_.has_value())
    return std::nullopt;
  _res.type = std::move(*_type_opt_);

  if (!_value.has("value"))
    return std::nullopt;
  auto _value_opt_ = from_json<std::string>(_value["value"]);
  if (!_value_opt_.has_value())
    return std::nullopt;
  _res.value = std::move(*_value_opt_);

  return _res;
}
#pragma endregion JSON serialization for object IgnoreItemPair

#pragma region JSON serialization for string enum StorageId
template <>
inline crow::json::wvalue to_json<Shared::StorageId>(Shared::StorageId _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::StorageId> {
  static inline std::optional<Shared::StorageId> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::StorageId>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum StorageId

#pragma region JSON serialization for string enum TranscodeFormatTargetName
template <>
inline crow::json::wvalue to_json<Shared::TranscodeFormatTargetName>(
    Shared::TranscodeFormatTargetName _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::TranscodeFormatTargetName> {
  static inline std::optional<Shared::TranscodeFormatTargetName> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::TranscodeFormatTargetName>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum TranscodeFormatTargetName

#pragma region JSON serialization for string enum TranscodeSource
template <>
inline crow::json::wvalue to_json<Shared::TranscodeSource>(
    Shared::TranscodeSource _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::TranscodeSource> {
  static inline std::optional<Shared::TranscodeSource> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::TranscodeSource>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum TranscodeSource

#pragma region JSON serialization for object TranscodeSourceLocation
template <>
struct impl_to_json<Shared::TranscodeSourceLocation> {
  static inline crow::json::wvalue process(
      const Shared::TranscodeSourceLocation& _value) {
    crow::json::wvalue _res;
    _res["type"] = to_json(_value.type);
    _res["loc"] = to_json(_value.loc);

    return _res;
  }
};

template <>
inline std::optional<Shared::TranscodeSourceLocation>
from_json<Shared::TranscodeSourceLocation>(const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::TranscodeSourceLocation _res;

  if (!_value.has("type"))
    return std::nullopt;
  auto _type_opt_ = from_json<Shared::TranscodeSource>(_value["type"]);
  if (!_type_opt_.has_value())
    return std::nullopt;
  _res.type = std::move(*_type_opt_);

  if (!_value.has("loc"))
    return std::nullopt;
  auto _loc_opt_ = from_json<std::string>(_value["loc"]);
  if (!_loc_opt_.has_value())
    return std::nullopt;
  _res.loc = std::move(*_loc_opt_);

  return _res;
}
#pragma endregion JSON serialization for object TranscodeSourceLocation

#pragma region JSON serialization for object FileFailure
template <>
struct impl_to_json<Shared::FileFailure> {
  static inline crow::json::wvalue process(const Shared::FileFailure& _value) {
    crow::json::wvalue _res;
    _res["file"] = to_json(_value.file);
    _res["error"] = to_json(_value.error);

    return _res;
  }
};

template <>
inline std::optional<Shared::FileFailure> from_json<Shared::FileFailure>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::FileFailure _res;

  if (!_value.has("file"))
    return std::nullopt;
  auto _file_opt_ = from_json<std::string>(_value["file"]);
  if (!_file_opt_.has_value())
    return std::nullopt;
  _res.file = std::move(*_file_opt_);

  if (!_value.has("error"))
    return std::nullopt;
  auto _error_opt_ = from_json<std::string>(_value["error"]);
  if (!_error_opt_.has_value())
    return std::nullopt;
  _res.error = std::move(*_error_opt_);

  return _res;
}
#pragma endregion JSON serialization for object FileFailure

#pragma region JSON serialization for object TranscodeState
template <>
struct impl_to_json<Shared::TranscodeState> {
  static inline crow::json::wvalue process(
      const Shared::TranscodeState& _value) {
    crow::json::wvalue _res;
    _res["curStatus"] = to_json(_value.curStatus);
    _res["filesTranscoded"] = to_json(_value.filesTranscoded);
    _res["filesFound"] = to_json(_value.filesFound);
    _res["filesPending"] = to_json(_value.filesPending);
    _res["filesUntouched"] = to_json(_value.filesUntouched);
    _res["filesFailed"] = to_json(_value.filesFailed);
    _res["itemsRemoved"] = to_json(_value.itemsRemoved);

    return _res;
  }
};

template <>
inline std::optional<Shared::TranscodeState> from_json<Shared::TranscodeState>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::TranscodeState _res;

  if (!_value.has("curStatus"))
    return std::nullopt;
  auto _curStatus_opt_ = from_json<std::string>(_value["curStatus"]);
  if (!_curStatus_opt_.has_value())
    return std::nullopt;
  _res.curStatus = std::move(*_curStatus_opt_);

  if (!_value.has("filesTranscoded"))
    return std::nullopt;
  auto _filesTranscoded_opt_ =
      from_json<std::vector<std::string>>(_value["filesTranscoded"]);
  if (!_filesTranscoded_opt_.has_value())
    return std::nullopt;
  _res.filesTranscoded = std::move(*_filesTranscoded_opt_);

  if (!_value.has("filesFound"))
    return std::nullopt;
  auto _filesFound_opt_ = from_json<std::int32_t>(_value["filesFound"]);
  if (!_filesFound_opt_.has_value())
    return std::nullopt;
  _res.filesFound = std::move(*_filesFound_opt_);

  if (!_value.has("filesPending"))
    return std::nullopt;
  auto _filesPending_opt_ = from_json<std::int32_t>(_value["filesPending"]);
  if (!_filesPending_opt_.has_value())
    return std::nullopt;
  _res.filesPending = std::move(*_filesPending_opt_);

  if (!_value.has("filesUntouched"))
    return std::nullopt;
  auto _filesUntouched_opt_ = from_json<std::int32_t>(_value["filesUntouched"]);
  if (!_filesUntouched_opt_.has_value())
    return std::nullopt;
  _res.filesUntouched = std::move(*_filesUntouched_opt_);

  if (!_value.has("filesFailed"))
    return std::nullopt;
  auto _filesFailed_opt_ =
      from_json<std::vector<Shared::FileFailure>>(_value["filesFailed"]);
  if (!_filesFailed_opt_.has_value())
    return std::nullopt;
  _res.filesFailed = std::move(*_filesFailed_opt_);

  if (!_value.has("itemsRemoved"))
    return std::nullopt;
  auto _itemsRemoved_opt_ =
      from_json<std::vector<std::string>>(_value["itemsRemoved"]);
  if (!_itemsRemoved_opt_.has_value())
    return std::nullopt;
  _res.itemsRemoved = std::move(*_itemsRemoved_opt_);

  return _res;
}
#pragma endregion JSON serialization for object TranscodeState

#pragma region JSON serialization for object TranscodeInfo
template <>
struct impl_to_json<Shared::TranscodeInfo> {
  static inline crow::json::wvalue process(
      const Shared::TranscodeInfo& _value) {
    crow::json::wvalue _res;
    _res["source"] = to_json(_value.source);
    _res["dest"] = to_json(_value.dest);
    _res["artwork"] = to_json(_value.artwork);
    _res["mirror"] = to_json(_value.mirror);
    _res["format"] = to_json(_value.format);
    _res["bitrate"] = to_json(_value.bitrate);

    return _res;
  }
};

template <>
inline std::optional<Shared::TranscodeInfo> from_json<Shared::TranscodeInfo>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::TranscodeInfo _res;

  if (!_value.has("source"))
    return std::nullopt;
  auto _source_opt_ =
      from_json<Shared::TranscodeSourceLocation>(_value["source"]);
  if (!_source_opt_.has_value())
    return std::nullopt;
  _res.source = std::move(*_source_opt_);

  if (!_value.has("dest"))
    return std::nullopt;
  auto _dest_opt_ = from_json<std::string>(_value["dest"]);
  if (!_dest_opt_.has_value())
    return std::nullopt;
  _res.dest = std::move(*_dest_opt_);

  if (!_value.has("artwork"))
    return std::nullopt;
  auto _artwork_opt_ = from_json<bool>(_value["artwork"]);
  if (!_artwork_opt_.has_value())
    return std::nullopt;
  _res.artwork = std::move(*_artwork_opt_);

  if (!_value.has("mirror"))
    return std::nullopt;
  auto _mirror_opt_ = from_json<bool>(_value["mirror"]);
  if (!_mirror_opt_.has_value())
    return std::nullopt;
  _res.mirror = std::move(*_mirror_opt_);

  if (!_value.has("format"))
    return std::nullopt;
  auto _format_opt_ =
      from_json<Shared::TranscodeFormatTargetName>(_value["format"]);
  if (!_format_opt_.has_value())
    return std::nullopt;
  _res.format = std::move(*_format_opt_);

  if (!_value.has("bitrate"))
    return std::nullopt;
  auto _bitrate_opt_ = from_json<std::uint16_t>(_value["bitrate"]);
  if (!_bitrate_opt_.has_value())
    return std::nullopt;
  _res.bitrate = std::move(*_bitrate_opt_);

  return _res;
}
#pragma endregion JSON serialization for object TranscodeInfo

#pragma region JSON serialization for object Song
template <>
struct impl_to_json<Shared::Song> {
  static inline crow::json::wvalue process(const Shared::Song& _value) {
    crow::json::wvalue _res;
    _res["key"] = to_json(_value.key);
    _res["track"] = to_json(_value.track);
    _res["title"] = to_json(_value.title);
    _res["albumId"] = to_json(_value.albumId);
    _res["artistIds"] = to_json(_value.artistIds);
    _res["secondaryIds"] = to_json(_value.secondaryIds);
    _res["variations"] = to_json(_value.variations);

    return _res;
  }
};

template <>
inline std::optional<Shared::Song> from_json<Shared::Song>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::Song _res;

  if (!_value.has("key"))
    return std::nullopt;
  auto _key_opt_ = from_json<Shared::SongKey>(_value["key"]);
  if (!_key_opt_.has_value())
    return std::nullopt;
  _res.key = std::move(*_key_opt_);

  if (!_value.has("track"))
    return std::nullopt;
  auto _track_opt_ = from_json<std::int16_t>(_value["track"]);
  if (!_track_opt_.has_value())
    return std::nullopt;
  _res.track = std::move(*_track_opt_);

  if (!_value.has("title"))
    return std::nullopt;
  auto _title_opt_ = from_json<std::string>(_value["title"]);
  if (!_title_opt_.has_value())
    return std::nullopt;
  _res.title = std::move(*_title_opt_);

  if (!_value.has("albumId"))
    return std::nullopt;
  auto _albumId_opt_ = from_json<Shared::AlbumKey>(_value["albumId"]);
  if (!_albumId_opt_.has_value())
    return std::nullopt;
  _res.albumId = std::move(*_albumId_opt_);

  if (!_value.has("artistIds"))
    return std::nullopt;
  auto _artistIds_opt_ =
      from_json<std::vector<Shared::ArtistKey>>(_value["artistIds"]);
  if (!_artistIds_opt_.has_value())
    return std::nullopt;
  _res.artistIds = std::move(*_artistIds_opt_);

  if (!_value.has("secondaryIds"))
    return std::nullopt;
  auto _secondaryIds_opt_ =
      from_json<std::vector<Shared::ArtistKey>>(_value["secondaryIds"]);
  if (!_secondaryIds_opt_.has_value())
    return std::nullopt;
  _res.secondaryIds = std::move(*_secondaryIds_opt_);

  if (!_value.has("variations"))
    return std::nullopt;
  auto _variations_opt_ =
      from_json<std::vector<std::string>>(_value["variations"]);
  if (!_variations_opt_.has_value())
    return std::nullopt;
  _res.variations = std::move(*_variations_opt_);

  return _res;
}
#pragma endregion JSON serialization for object Song

#pragma region JSON serialization for object SongWithPath
template <>
struct impl_to_json<Shared::SongWithPath> {
  static inline crow::json::wvalue process(const Shared::SongWithPath& _value) {
    crow::json::wvalue _res = impl_to_json<Shared::Song>::process(_value);
    _res["path"] = to_json(_value.path);
    return _res;
  }
};

template <>
inline std::optional<Shared::SongWithPath> from_json<Shared::SongWithPath>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  std::optional<Shared::Song> _base = from_json<Shared::Song>(_value);
  if (!_base.has_value())
    return std::nullopt;

  if (!_value.has("path"))
    return std::nullopt;
  auto _path_opt_ = from_json<std::string>(_value["path"]);
  if (!_path_opt_.has_value())
    return std::nullopt;

  Shared::SongWithPath _res{std::move(*_base), std::move(*_path_opt_)};

  return _res;
}
#pragma endregion JSON serialization for object SongWithPath

#pragma region JSON serialization for string enum VAType
template <>
inline crow::json::wvalue to_json<Shared::VAType>(Shared::VAType _value) {
  return to_json(to_string(_value));
}
template <>
struct impl_from_json<Shared::VAType> {
  static inline std::optional<Shared::VAType> process(
      const crow::json::rvalue& _value) {
    if (_value.t() != crow::json::type::String)
      return std::nullopt;
    auto _str = _value.s();
    return Shared::from_string<Shared::VAType>(
        std::string_view{_str.begin(), _str.size()});
  }
};
#pragma endregion JSON serialization for string enum VAType

#pragma region JSON serialization for object Artist
template <>
struct impl_to_json<Shared::Artist> {
  static inline crow::json::wvalue process(const Shared::Artist& _value) {
    crow::json::wvalue _res;
    _res["key"] = to_json(_value.key);
    _res["name"] = to_json(_value.name);
    _res["albums"] = to_json(_value.albums);
    _res["songs"] = to_json(_value.songs);

    return _res;
  }
};

template <>
inline std::optional<Shared::Artist> from_json<Shared::Artist>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::Artist _res;

  if (!_value.has("key"))
    return std::nullopt;
  auto _key_opt_ = from_json<Shared::ArtistKey>(_value["key"]);
  if (!_key_opt_.has_value())
    return std::nullopt;
  _res.key = std::move(*_key_opt_);

  if (!_value.has("name"))
    return std::nullopt;
  auto _name_opt_ = from_json<std::string>(_value["name"]);
  if (!_name_opt_.has_value())
    return std::nullopt;
  _res.name = std::move(*_name_opt_);

  if (!_value.has("albums"))
    return std::nullopt;
  auto _albums_opt_ =
      from_json<std::vector<Shared::AlbumKey>>(_value["albums"]);
  if (!_albums_opt_.has_value())
    return std::nullopt;
  _res.albums = std::move(*_albums_opt_);

  if (!_value.has("songs"))
    return std::nullopt;
  auto _songs_opt_ = from_json<std::vector<Shared::SongKey>>(_value["songs"]);
  if (!_songs_opt_.has_value())
    return std::nullopt;
  _res.songs = std::move(*_songs_opt_);

  return _res;
}
#pragma endregion JSON serialization for object Artist

#pragma region JSON serialization for object Album
template <>
struct impl_to_json<Shared::Album> {
  static inline crow::json::wvalue process(const Shared::Album& _value) {
    crow::json::wvalue _res;
    _res["key"] = to_json(_value.key);
    _res["year"] = to_json(_value.year);
    _res["title"] = to_json(_value.title);
    _res["vatype"] = to_json(_value.vatype);
    _res["primaryArtists"] = to_json(_value.primaryArtists);
    _res["songs"] = to_json(_value.songs);
    _res["diskNames"] = to_json(_value.diskNames);

    return _res;
  }
};

template <>
inline std::optional<Shared::Album> from_json<Shared::Album>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::Album _res;

  if (!_value.has("key"))
    return std::nullopt;
  auto _key_opt_ = from_json<Shared::AlbumKey>(_value["key"]);
  if (!_key_opt_.has_value())
    return std::nullopt;
  _res.key = std::move(*_key_opt_);

  if (!_value.has("year"))
    return std::nullopt;
  auto _year_opt_ = from_json<std::int16_t>(_value["year"]);
  if (!_year_opt_.has_value())
    return std::nullopt;
  _res.year = std::move(*_year_opt_);

  if (!_value.has("title"))
    return std::nullopt;
  auto _title_opt_ = from_json<std::string>(_value["title"]);
  if (!_title_opt_.has_value())
    return std::nullopt;
  _res.title = std::move(*_title_opt_);

  if (!_value.has("vatype"))
    return std::nullopt;
  auto _vatype_opt_ = from_json<Shared::VAType>(_value["vatype"]);
  if (!_vatype_opt_.has_value())
    return std::nullopt;
  _res.vatype = std::move(*_vatype_opt_);

  if (!_value.has("primaryArtists"))
    return std::nullopt;
  auto _primaryArtists_opt_ =
      from_json<std::vector<Shared::ArtistKey>>(_value["primaryArtists"]);
  if (!_primaryArtists_opt_.has_value())
    return std::nullopt;
  _res.primaryArtists = std::move(*_primaryArtists_opt_);

  if (!_value.has("songs"))
    return std::nullopt;
  auto _songs_opt_ = from_json<std::vector<Shared::SongKey>>(_value["songs"]);
  if (!_songs_opt_.has_value())
    return std::nullopt;
  _res.songs = std::move(*_songs_opt_);

  if (!_value.has("diskNames"))
    return std::nullopt;
  auto _diskNames_opt_ =
      from_json<std::vector<std::string>>(_value["diskNames"]);
  if (!_diskNames_opt_.has_value())
    return std::nullopt;
  _res.diskNames = std::move(*_diskNames_opt_);

  return _res;
}
#pragma endregion JSON serialization for object Album

#pragma region JSON serialization for object MediaInfo
template <>
struct impl_to_json<Shared::MediaInfo> {
  static inline crow::json::wvalue process(const Shared::MediaInfo& _value) {
    crow::json::wvalue _res;
    _res["general"] = to_json(_value.general);
    _res["audio"] = to_json(_value.audio);

    return _res;
  }
};

template <>
inline std::optional<Shared::MediaInfo> from_json<Shared::MediaInfo>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::MediaInfo _res;

  if (!_value.has("general"))
    return std::nullopt;
  auto _general_opt_ =
      from_json<std::map<std::string, std::string>>(_value["general"]);
  if (!_general_opt_.has_value())
    return std::nullopt;
  _res.general = std::move(*_general_opt_);

  if (!_value.has("audio"))
    return std::nullopt;
  auto _audio_opt_ =
      from_json<std::map<std::string, std::string>>(_value["audio"]);
  if (!_audio_opt_.has_value())
    return std::nullopt;
  _res.audio = std::move(*_audio_opt_);

  return _res;
}
#pragma endregion JSON serialization for object MediaInfo

#pragma region JSON serialization for object SimpleMetadata
template <>
struct impl_to_json<Shared::SimpleMetadata> {
  static inline crow::json::wvalue process(
      const Shared::SimpleMetadata& _value) {
    crow::json::wvalue _res;
    _res["artist"] = to_json(_value.artist);
    _res["album"] = to_json(_value.album);
    _res["year"] = to_json(_value.year);
    _res["track"] = to_json(_value.track);
    _res["title"] = to_json(_value.title);
    _res["discNum"] = to_json(_value.discNum);
    _res["discName"] = to_json(_value.discName);
    _res["compilation"] = to_json(_value.compilation);

    return _res;
  }
};

template <>
inline std::optional<Shared::SimpleMetadata> from_json<Shared::SimpleMetadata>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::SimpleMetadata _res;

  if (!_value.has("artist"))
    return std::nullopt;
  auto _artist_opt_ = from_json<std::string>(_value["artist"]);
  if (!_artist_opt_.has_value())
    return std::nullopt;
  _res.artist = std::move(*_artist_opt_);

  if (!_value.has("album"))
    return std::nullopt;
  auto _album_opt_ = from_json<std::string>(_value["album"]);
  if (!_album_opt_.has_value())
    return std::nullopt;
  _res.album = std::move(*_album_opt_);

  if (!_value.has("year"))
    return std::nullopt;
  auto _year_opt_ = from_json<std::string>(_value["year"]);
  if (!_year_opt_.has_value())
    return std::nullopt;
  _res.year = std::move(*_year_opt_);

  if (!_value.has("track"))
    return std::nullopt;
  auto _track_opt_ = from_json<std::string>(_value["track"]);
  if (!_track_opt_.has_value())
    return std::nullopt;
  _res.track = std::move(*_track_opt_);

  if (!_value.has("title"))
    return std::nullopt;
  auto _title_opt_ = from_json<std::string>(_value["title"]);
  if (!_title_opt_.has_value())
    return std::nullopt;
  _res.title = std::move(*_title_opt_);

  if (!_value.has("discNum"))
    return std::nullopt;
  auto _discNum_opt_ = from_json<std::string>(_value["discNum"]);
  if (!_discNum_opt_.has_value())
    return std::nullopt;
  _res.discNum = std::move(*_discNum_opt_);

  if (!_value.has("discName"))
    return std::nullopt;
  auto _discName_opt_ = from_json<std::string>(_value["discName"]);
  if (!_discName_opt_.has_value())
    return std::nullopt;
  _res.discName = std::move(*_discName_opt_);

  if (!_value.has("compilation"))
    return std::nullopt;
  auto _compilation_opt_ = from_json<Shared::VAType>(_value["compilation"]);
  if (!_compilation_opt_.has_value())
    return std::nullopt;
  _res.compilation = std::move(*_compilation_opt_);

  return _res;
}
#pragma endregion JSON serialization for object SimpleMetadata

#pragma region JSON serialization for object FullMetadata
template <>
struct impl_to_json<Shared::FullMetadata> {
  static inline crow::json::wvalue process(const Shared::FullMetadata& _value) {
    crow::json::wvalue _res;
    _res["originalPath"] = to_json(_value.originalPath);
    _res["artist"] = to_json(_value.artist);
    _res["album"] = to_json(_value.album);
    _res["year"] = to_json(_value.year);
    _res["track"] = to_json(_value.track);
    _res["title"] = to_json(_value.title);
    _res["vaType"] = to_json(_value.vaType);
    _res["moreArtists"] = to_json(_value.moreArtists);
    _res["variations"] = to_json(_value.variations);
    _res["disk"] = to_json(_value.disk);
    _res["diskName"] = to_json(_value.diskName);

    return _res;
  }
};

template <>
inline std::optional<Shared::FullMetadata> from_json<Shared::FullMetadata>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::FullMetadata _res;

  if (!_value.has("originalPath"))
    return std::nullopt;
  auto _originalPath_opt_ = from_json<std::string>(_value["originalPath"]);
  if (!_originalPath_opt_.has_value())
    return std::nullopt;
  _res.originalPath = std::move(*_originalPath_opt_);

  if (!_value.has("artist"))
    return std::nullopt;
  auto _artist_opt_ = from_json<std::vector<std::string>>(_value["artist"]);
  if (!_artist_opt_.has_value())
    return std::nullopt;
  _res.artist = std::move(*_artist_opt_);

  if (!_value.has("album"))
    return std::nullopt;
  auto _album_opt_ = from_json<std::string>(_value["album"]);
  if (!_album_opt_.has_value())
    return std::nullopt;
  _res.album = std::move(*_album_opt_);

  if (!_value.has("year"))
    return std::nullopt;
  auto _year_opt_ = from_json<std::int16_t>(_value["year"]);
  if (!_year_opt_.has_value())
    return std::nullopt;
  _res.year = std::move(*_year_opt_);

  if (!_value.has("track"))
    return std::nullopt;
  auto _track_opt_ = from_json<std::int16_t>(_value["track"]);
  if (!_track_opt_.has_value())
    return std::nullopt;
  _res.track = std::move(*_track_opt_);

  if (!_value.has("title"))
    return std::nullopt;
  auto _title_opt_ = from_json<std::string>(_value["title"]);
  if (!_title_opt_.has_value())
    return std::nullopt;
  _res.title = std::move(*_title_opt_);

  if (!_value.has("vaType"))
    return std::nullopt;
  auto _vaType_opt_ = from_json<Shared::VAType>(_value["vaType"]);
  if (!_vaType_opt_.has_value())
    return std::nullopt;
  _res.vaType = std::move(*_vaType_opt_);

  if (!_value.has("moreArtists"))
    return std::nullopt;
  auto _moreArtists_opt_ =
      from_json<std::vector<std::string>>(_value["moreArtists"]);
  if (!_moreArtists_opt_.has_value())
    return std::nullopt;
  _res.moreArtists = std::move(*_moreArtists_opt_);

  if (!_value.has("variations"))
    return std::nullopt;
  auto _variations_opt_ =
      from_json<std::vector<std::string>>(_value["variations"]);
  if (!_variations_opt_.has_value())
    return std::nullopt;
  _res.variations = std::move(*_variations_opt_);

  if (!_value.has("disk"))
    return std::nullopt;
  auto _disk_opt_ = from_json<std::int16_t>(_value["disk"]);
  if (!_disk_opt_.has_value())
    return std::nullopt;
  _res.disk = std::move(*_disk_opt_);

  if (!_value.has("diskName"))
    return std::nullopt;
  auto _diskName_opt_ = from_json<std::string>(_value["diskName"]);
  if (!_diskName_opt_.has_value())
    return std::nullopt;
  _res.diskName = std::move(*_diskName_opt_);

  return _res;
}
#pragma endregion JSON serialization for object FullMetadata

#pragma region JSON serialization for object AudioFileRegexPattern
template <>
struct impl_to_json<Shared::AudioFileRegexPattern> {
  static inline crow::json::wvalue process(
      const Shared::AudioFileRegexPattern& _value) {
    crow::json::wvalue _res;
    _res["compilation"] = to_json(_value.compilation);
    _res["rgx"] = to_json(_value.rgx);

    return _res;
  }
};

template <>
inline std::optional<Shared::AudioFileRegexPattern>
from_json<Shared::AudioFileRegexPattern>(const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::AudioFileRegexPattern _res;

  if (!_value.has("compilation"))
    return std::nullopt;
  auto _compilation_opt_ = from_json<Shared::VAType>(_value["compilation"]);
  if (!_compilation_opt_.has_value())
    return std::nullopt;
  _res.compilation = std::move(*_compilation_opt_);

  if (!_value.has("rgx"))
    return std::nullopt;
  auto _rgx_opt_ = from_json<std::string>(_value["rgx"]);
  if (!_rgx_opt_.has_value())
    return std::nullopt;
  _res.rgx = std::move(*_rgx_opt_);

  return _res;
}
#pragma endregion JSON serialization for object AudioFileRegexPattern

#pragma region JSON serialization for object MimeData
template <>
struct impl_to_json<Shared::MimeData> {
  static inline crow::json::wvalue process(const Shared::MimeData& _value) {
    crow::json::wvalue _res;
    _res["type"] = to_json(_value.type);
    _res["data"] = to_json(_value.data);

    return _res;
  }
};

template <>
inline std::optional<Shared::MimeData> from_json<Shared::MimeData>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::MimeData _res;

  if (!_value.has("type"))
    return std::nullopt;
  auto _type_opt_ = from_json<std::string>(_value["type"]);
  if (!_type_opt_.has_value())
    return std::nullopt;
  _res.type = std::move(*_type_opt_);

  if (!_value.has("data"))
    return std::nullopt;
  auto _data_opt_ = from_json<std::string>(_value["data"]);
  if (!_data_opt_.has_value())
    return std::nullopt;
  _res.data = std::move(*_data_opt_);

  return _res;
}
#pragma endregion JSON serialization for object MimeData

#pragma region JSON serialization for object MusicDatabase
template <>
struct impl_to_json<Shared::MusicDatabase> {
  static inline crow::json::wvalue process(
      const Shared::MusicDatabase& _value) {
    crow::json::wvalue _res;
    _res["artists"] = to_json(_value.artists);
    _res["albums"] = to_json(_value.albums);
    _res["songs"] = to_json(_value.songs);
    _res["playlists"] = to_json(_value.playlists);

    return _res;
  }
};

template <>
inline std::optional<Shared::MusicDatabase> from_json<Shared::MusicDatabase>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::MusicDatabase _res;

  if (!_value.has("artists"))
    return std::nullopt;
  auto _artists_opt_ =
      from_json<std::unordered_map<Shared::ArtistKey, Shared::Artist>>(
          _value["artists"]);
  if (!_artists_opt_.has_value())
    return std::nullopt;
  _res.artists = std::move(*_artists_opt_);

  if (!_value.has("albums"))
    return std::nullopt;
  auto _albums_opt_ =
      from_json<std::unordered_map<Shared::AlbumKey, Shared::Album>>(
          _value["albums"]);
  if (!_albums_opt_.has_value())
    return std::nullopt;
  _res.albums = std::move(*_albums_opt_);

  if (!_value.has("songs"))
    return std::nullopt;
  auto _songs_opt_ =
      from_json<std::unordered_map<Shared::SongKey, Shared::Song>>(
          _value["songs"]);
  if (!_songs_opt_.has_value())
    return std::nullopt;
  _res.songs = std::move(*_songs_opt_);

  if (!_value.has("playlists"))
    return std::nullopt;
  auto _playlists_opt_ =
      from_json<std::map<std::string, Shared::Playlist>>(_value["playlists"]);
  if (!_playlists_opt_.has_value())
    return std::nullopt;
  _res.playlists = std::move(*_playlists_opt_);

  return _res;
}
#pragma endregion JSON serialization for object MusicDatabase

#pragma region JSON serialization for object FileFilterItem
template <>
struct impl_to_json<Shared::FileFilterItem> {
  static inline crow::json::wvalue process(
      const Shared::FileFilterItem& _value) {
    crow::json::wvalue _res;
    _res["name"] = to_json(_value.name);
    _res["extensions"] = to_json(_value.extensions);

    return _res;
  }
};

template <>
inline std::optional<Shared::FileFilterItem> from_json<Shared::FileFilterItem>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::FileFilterItem _res;

  if (!_value.has("name"))
    return std::nullopt;
  auto _name_opt_ = from_json<std::string>(_value["name"]);
  if (!_name_opt_.has_value())
    return std::nullopt;
  _res.name = std::move(*_name_opt_);

  if (!_value.has("extensions"))
    return std::nullopt;
  auto _extensions_opt_ =
      from_json<std::vector<std::string>>(_value["extensions"]);
  if (!_extensions_opt_.has_value())
    return std::nullopt;
  _res.extensions = std::move(*_extensions_opt_);

  return _res;
}
#pragma endregion JSON serialization for object FileFilterItem

#pragma region JSON serialization for object OpenDialogOptions
template <>
struct impl_to_json<Shared::OpenDialogOptions> {
  static inline crow::json::wvalue process(
      const Shared::OpenDialogOptions& _value) {
    crow::json::wvalue _res;

    if (_value.folder) {
      _res["folder"] = to_json(*_value.folder);
    }
    if (_value.title) {
      _res["title"] = to_json(*_value.title);
    }
    if (_value.defaultPath) {
      _res["defaultPath"] = to_json(*_value.defaultPath);
    }
    if (_value.buttonLabel) {
      _res["buttonLabel"] = to_json(*_value.buttonLabel);
    }
    if (_value.multiSelections) {
      _res["multiSelections"] = to_json(*_value.multiSelections);
    }
    if (_value.filters) {
      _res["filters"] = to_json(*_value.filters);
    }
    return _res;
  }
};

template <>
inline std::optional<Shared::OpenDialogOptions>
from_json<Shared::OpenDialogOptions>(const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::OpenDialogOptions _res;

  if (_value.has("folder")) {
    auto _folder_opt_ = from_json<bool>(_value["folder"]);
    if (!_folder_opt_.has_value())
      return std::nullopt;
    _res.folder = std::move(*_folder_opt_);
  } else {
    _res.folder = std::nullopt;
  }

  if (_value.has("title")) {
    auto _title_opt_ = from_json<std::string>(_value["title"]);
    if (!_title_opt_.has_value())
      return std::nullopt;
    _res.title = std::move(*_title_opt_);
  } else {
    _res.title = std::nullopt;
  }

  if (_value.has("defaultPath")) {
    auto _defaultPath_opt_ = from_json<std::string>(_value["defaultPath"]);
    if (!_defaultPath_opt_.has_value())
      return std::nullopt;
    _res.defaultPath = std::move(*_defaultPath_opt_);
  } else {
    _res.defaultPath = std::nullopt;
  }

  if (_value.has("buttonLabel")) {
    auto _buttonLabel_opt_ = from_json<std::string>(_value["buttonLabel"]);
    if (!_buttonLabel_opt_.has_value())
      return std::nullopt;
    _res.buttonLabel = std::move(*_buttonLabel_opt_);
  } else {
    _res.buttonLabel = std::nullopt;
  }

  if (_value.has("multiSelections")) {
    auto _multiSelections_opt_ = from_json<bool>(_value["multiSelections"]);
    if (!_multiSelections_opt_.has_value())
      return std::nullopt;
    _res.multiSelections = std::move(*_multiSelections_opt_);
  } else {
    _res.multiSelections = std::nullopt;
  }

  if (_value.has("filters")) {
    auto _filters_opt_ =
        from_json<std::vector<Shared::FileFilterItem>>(_value["filters"]);
    if (!_filters_opt_.has_value())
      return std::nullopt;
    _res.filters = std::move(*_filters_opt_);
  } else {
    _res.filters = std::nullopt;
  }
  return _res;
}
#pragma endregion JSON serialization for object OpenDialogOptions

#pragma region JSON serialization for object SearchResults
template <>
struct impl_to_json<Shared::SearchResults> {
  static inline crow::json::wvalue process(
      const Shared::SearchResults& _value) {
    crow::json::wvalue _res;
    _res["songs"] = to_json(_value.songs);
    _res["artists"] = to_json(_value.artists);
    _res["albums"] = to_json(_value.albums);

    return _res;
  }
};

template <>
inline std::optional<Shared::SearchResults> from_json<Shared::SearchResults>(
    const crow::json::rvalue& _value) {
  if (_value.t() != crow::json::type::Object)
    return std::nullopt;
  Shared::SearchResults _res;

  if (!_value.has("songs"))
    return std::nullopt;
  auto _songs_opt_ = from_json<std::vector<Shared::SongKey>>(_value["songs"]);
  if (!_songs_opt_.has_value())
    return std::nullopt;
  _res.songs = std::move(*_songs_opt_);

  if (!_value.has("artists"))
    return std::nullopt;
  auto _artists_opt_ =
      from_json<std::vector<Shared::ArtistKey>>(_value["artists"]);
  if (!_artists_opt_.has_value())
    return std::nullopt;
  _res.artists = std::move(*_artists_opt_);

  if (!_value.has("albums"))
    return std::nullopt;
  auto _albums_opt_ =
      from_json<std::vector<Shared::AlbumKey>>(_value["albums"]);
  if (!_albums_opt_.has_value())
    return std::nullopt;
  _res.albums = std::move(*_albums_opt_);

  return _res;
}
#pragma endregion JSON serialization for object SearchResults

#endif // CPP_INCLUDE_COMMONTYPES_HPP
