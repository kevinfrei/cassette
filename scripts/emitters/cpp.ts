import {
  ArrType,
  Enum,
  isArrayType,
  isBoolType,
  isCharType,
  isDoubleType,
  isFloatType,
  isI16Type,
  isI32Type,
  isI64Type,
  isI8Type,
  isMapType,
  isPlainIntEnumType,
  isRefType,
  isSetType,
  isStringType,
  isTupleType,
  isU16Type,
  isU32Type,
  isU64Type,
  isU8Type,
  MapType,
  NEnum,
  ObjType,
  SEnum,
  SetType,
  Str,
  TupType,
  Types,
} from '../../www/Shared/IDL';
import { EmitItem, Emitter, FileGenerator, MakeGenerator } from './api';

async function header(writer: Bun.FileSink): Promise<void> {
  await writer.write(`// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from www/Shared/Enums.ts by running 'bun gen'
// If you need to change this file, edit www/Shared/Enums.ts and run
// 'bun gen' again. Or, if you need to change the generation
// process, edit scripts/emitters/cpp.ts and run 'bun gen' again.
// DO NOT EDIT THIS FILE DIRECTLY!!!

#pragma once

#ifndef SHARED_CONSTANTS_HPP
#define SHARED_CONSTANTS_HPP

#include <crow/json.h>
#include <cstdint>
#include <map>
#include <optional>
#include <set>
#include <string>
#include <string_view>
#include <tuple>
#include <vector>

namespace Shared {
template <typename T>
constexpr std::optional<T> from_string(const std::string_view& str);
`);
}

async function footer(writer: Bun.FileSink): Promise<void> {
  await writer.write(`

} // namespace Shared

#endif // SHARED_CONSTANTS_HPP
`);
}

function getTypeName(type: Types): string {
  if (isU8Type(type)) {
    return 'std::uint8_t';
  } else if (isI8Type(type)) {
    return 'std::int8_t';
  } else if (isU16Type(type)) {
    return 'std::uint16_t';
  } else if (isI16Type(type)) {
    return 'std::int16_t';
  } else if (isU32Type(type)) {
    return 'std::uint32_t';
  } else if (isI32Type(type)) {
    return 'std::int32_t';
  } else if (isU64Type(type)) {
    return 'std::uint64_t';
  } else if (isI64Type(type)) {
    return 'std::int64_t';
  } else if (isStringType(type)) {
    return 'std::string';
  } else if (isCharType(type)) {
    return 'char';
  } else if (isBoolType(type)) {
    return 'bool';
  } else if (isFloatType(type)) {
    return 'float';
  } else if (isDoubleType(type)) {
    return 'double';
  } else if (isRefType(type)) {
    return type.r; // Reference type, just return the name
  } else if (isArrayType(type)) {
    return `std::vector<${getTypeName(type.d)}>`;
  } else if (isSetType(type)) {
    return `std::set<${getTypeName(type.d)}>`;
  } else if (isMapType(type)) {
    return `std::map<${getTypeName(type.k)}, ${getTypeName(type.v)}>`;
  } else if (isTupleType(type)) {
    return `std::tuple<${type.l.map(getTypeName).join(', ')}>`;
  }
  throw new Error(`Unsupported unnamed type: ${JSON.stringify(type)}`);
}

const enumType: EmitItem<Enum> = async (writer, name, item) => {
  const typeName = isPlainIntEnumType(item.u)
    ? ''
    : ` : ${getTypeName(item.u)}`;
  await writer.write(`
enum class ${name}${typeName} {
  ${item.v.join(',\n  ')}
};

inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${item.v.map((val) => `    case ${name}::${val}:`).join('\n')}
      return true;
    default:
      return false;
  }
}
`);
};

const numEnumType: EmitItem<NEnum> = async (writer, name, item) => {
  const typeName = isPlainIntEnumType(item.u)
    ? ''
    : ` : ${getTypeName(item.u)}`;
  await writer.write(`
enum class ${name}${typeName} {
${Object.entries(item.v)
  .map(([key, value]) => `  ${key} = ${value},`)
  .join('\n')}
};

inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(([key]) => `    case ${name}::${key}:`)
  .join('\n')}
      return true;
    default:
      return false;
  }
}
`);
};

const strEnumType: EmitItem<SEnum> = async (writer, name, item) => {
  await writer.write(`
// ${name}
enum class ${name} {
  ${Object.keys(item.v)
    .map((key) => `${key}`)
    .join(',\n  ')}
};
inline constexpr bool is_valid(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(([key]) => `    case ${name}::${key}:`)
  .join('\n')}
      return true;
    default:
      return false;
  }
}
`);

  await writer.write(`
inline constexpr std::string_view to_string(${name} _value) {
  switch (_value) {
${Object.entries(item.v)
  .map(
    ([key, val]) => `    case ${name}::${key}:
      return "${val}";`,
  )
  .join('\n')}
    default:
      return "<unknown>";
  }
}
`);

  // This is *super* simplistic, and could be optimized in various ways...
  await writer.write(`
template <>
inline constexpr std::optional<${name}> from_string<${name}>(
    const std::string_view& str) {
${Object.entries(item.v)
  .map(
    ([key, val]) => `  if (str == "${val}")
    return ${name}::${key};`,
  )
  .join('\n')}
  return std::nullopt;
}
`);
};

const objType: EmitItem<ObjType> = async (writer, name, item) => {
  await writer.write(`\nstruct ${name} {\n`);
  for (const [key, value] of Object.entries(item.d)) {
    const typeName = getTypeName(value);
    await writer.write(`  ${typeName} ${key};\n`);
  }
  await writer.write(`};\n`);
};

const usingType: EmitItem<Types> = async (writer, name, item) => {
  // This is a base type, so we don't need to do anything special
  await writer.write(`
using ${name} = ${getTypeName(item)};
`);
};

export const CppEmitter: Emitter = {
  header,
  footer,
  types: {
    objType,
    arrType: usingType,
    setType: usingType,
    mapType: usingType,
    tupType: usingType,
    enumType,
    strType: usingType,
    numEnumType,
    strEnumType,
  },
};

export function GetCppGenerator(): FileGenerator {
  // Returns the CppEmitter instance
  return MakeGenerator(CppEmitter);
}
