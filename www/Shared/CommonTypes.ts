// DO NOT EDIT THIS FILE DIRECTLY!!!
// This file is generated from www/Shared/Definitions.ts by running 'bun gen'
// If you need to change this file, edit www/Shared/Definitions.ts and run
// 'bun gen' again. Or, if you need to change the generation process, edit
// scripts/emitters/typescript.ts and run 'bun gen' again.
// DO NOT EDIT THIS FILE DIRECTLY!!!

import * as TypeChk from '@freik/typechk';

const chkIdlU8 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 255 && Number.isInteger(v);
const chkIdlI8 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= -256 && v <= 255 && Number.isInteger(v);
const chkIdlU16 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 65535 && Number.isInteger(v);
const chkIdlI16 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= -32768 && v <= 32767 && Number.isInteger(v);
const chkIdlU32 = (v: unknown): v is number =>
  TypeChk.isNumber(v) && v >= 0 && v <= 4294967295 && Number.isInteger(v);
const chkIdlI32 = (v: unknown): v is number =>
  TypeChk.isNumber(v) &&
  v >= -2147483648 &&
  v <= 2147483647 &&
  Number.isInteger(v);
function chkIdlU64(v: unknown): v is number {
  if (chkIdlU32(v)) {
    return true;
  }
  if (TypeChk.isNumber(v) && Number.isInteger(v) && v >= 0 && v < 2 << 54) {
    return true;
  }
  return true; // TODO: Check for a BigInt
}
function chkIdlI64(v: unknown): v is number {
  if (chkIdlI32(v)) {
    return true;
  }
  if (
    TypeChk.isNumber(v) &&
    Number.isInteger(v) &&
    v >= -(2 << 53) &&
    v < 2 << 53
  ) {
    return true;
  }
  return true; // TODO: Check for a BigInt
}
const chkIdlChar: TypeChk.typecheck<string> = (v: unknown): v is string =>
  TypeChk.isString(v) && v.length === 1;
function chkOptional<T>(
  chk: TypeChk.typecheck<T>,
): TypeChk.typecheck<T | undefined> {
  return (v: unknown): v is T | undefined => v === undefined || chk(v);
}

export const Keys = Object.freeze({
  AddFileLocation: 'O',
  Albums: '2',
  Artists: '3',
  Backward10s: '[',
  Find: 'F',
  Forward10s: ']',
  NextTrack: 'Right',
  NowPlaying: '1',
  Play: 'P',
  Playlists: '5',
  PreviousTrack: 'Left',
  Repeat: 'T',
  SavePlaylist: 'S',
  Settings: ',',
  Shuffle: 'R',
  Songs: '4',
  ToggleMiniPlayer: '9',
  Tools: 'L',
});
export type Keys = (typeof Keys)[keyof typeof Keys];
export function chkKeys(val: unknown): val is Keys {
  return TypeChk.isString(val) && Object.values(Keys).includes(val as Keys);
}

export const StrId = Object.freeze({
  Mono: 'mono',
  Stereo: 'stereo',
  Quadrophonic: 'quadrophonic',
  Channels: ' channels',
  BitDepth: 'bit',
  FilePath: 'File Path',
  Duration: 'Duration:',
  MDHeaderField: 'Field',
  MDHeaderValue: 'Value',
  FilesSelected: 'Files Selected',
  RawMetadata: 'Raw Metadata',
  ChooseCoverArt: 'Select Cover Art Image',
  ImageName: 'Images',
  ErrNotSingleAndNotMultiple: 'Not Single and not Multiple (This is a bug!)',
  ErrSingleAndMultiple: 'Both Single and Multiple (This is a bug!)',
  Title: 'Title',
  ArtistTooltip:
    "Multiple artists are specified like this: 'Artist 1, Artist 2 & Artist 3'",
  Artists: 'Artist(s)',
  Album: 'Album',
  Year: 'Year',
  TrackNum: 'Track #',
  DiskNum: 'Disk #',
  DiskName: 'Disk Name',
  Compilation: 'Compilation',
  Soundtrack: 'Soundtrack',
  AdditionalArtists: 'Additional Artist(s)',
  VariationsTooltip: 'Separate vartiations with a semicolon',
  Variations: 'Variation(s)',
  AlbumCover: 'Album Cover',
  ChooseFile: 'Choose File...',
  FromClipboard: 'From Clipboard',
  ViewNowPlaying: 'Now Playing',
  ViewAlbums: 'Albums',
  ViewArtists: 'Artists',
  ViewSongs: 'All Songs',
  ViewPlaylists: 'Playlists',
  ViewSettings: 'Settings',
  ViewTools: 'Tools',
  ImportFiles: 'Import Files...',
});
export type StrId = (typeof StrId)[keyof typeof StrId];
export function chkStrId(val: unknown): val is StrId {
  return TypeChk.isString(val) && Object.values(StrId).includes(val as StrId);
}

export const CurrentView = Object.freeze({
  disabled: -1,
  none: 0,
  recent: 1,
  albums: 2,
  artists: 3,
  songs: 4,
  playlists: 5,
  now_playing: 6,
  settings: 7,
  search: 8,
  tools: 9,
});
export type CurrentView = (typeof CurrentView)[keyof typeof CurrentView];
export function chkCurrentView(val: unknown): val is CurrentView {
  return (
    TypeChk.isNumber(val) &&
    Object.values(CurrentView).includes(val as CurrentView)
  );
}

export const IpcCall = Object.freeze({
  Unknown: 0,
  ReadFromStorage: 1,
  WriteToStorage: 2,
  DeleteFromStorage: 3,
  AsyncData: 4,
  IsDev: 5,
  ClearHates: 6,
  ClearLikes: 7,
  ClearLocalOverrides: 8,
  DeletePlaylist: 9,
  FlushImageCache: 10,
  FlushMetadataCache: 11,
  GetHates: 12,
  GetLikes: 13,
  GetMediaInfo: 14,
  GetMusicDatabase: 15,
  GetPlaylists: 16,
  LoadPlaylist: 17,
  MenuAction: 18,
  RenamePlaylist: 19,
  SavePlaylist: 20,
  Search: 21,
  SetHates: 22,
  SetLikes: 23,
  SetMediaInfo: 24,
  SetPlaylists: 25,
  SetSaveMenu: 26,
  ShowFile: 27,
  ShowLocFromKey: 28,
  ShowMenu: 29,
  SubstrSearch: 30,
  TranscodingBegin: 31,
  UploadImage: 32,
  MinimizeWindow: 33,
  MaximizeWindow: 34,
  RestoreWindow: 35,
  CloseWindow: 36,
  GetPicUri: 37,
  GetIgnoreList: 38,
  AddIgnoreItem: 39,
  RemoveIgnoreItem: 40,
  PushIgnoreList: 41,
  IgnoreListId: 42,
  ShowOpenDialog: 43,
});
export type IpcCall = (typeof IpcCall)[keyof typeof IpcCall];
export function chkIpcCall(val: unknown): val is IpcCall {
  return (
    TypeChk.isNumber(val) && Object.values(IpcCall).includes(val as IpcCall)
  );
}

export const SocketMsg = Object.freeze({
  Unknown: 0,
  TranscodingUpdate: 1,
  ManualRescan: 2,
  RescanInProgress: 3,
  RescanComplete: 4,
  MusicDBUpdate: 5,
  ContentLoaded: 6,
  KeepAlive: 7,
});
export type SocketMsg = (typeof SocketMsg)[keyof typeof SocketMsg];
export function chkSocketMsg(val: unknown): val is SocketMsg {
  return (
    TypeChk.isNumber(val) && Object.values(SocketMsg).includes(val as SocketMsg)
  );
}

export const IgnoreItemType = Object.freeze({
  PathRoot: 'path-root',
  PathKeyword: 'path-keyword',
  DirName: 'dir-name',
});
export type IgnoreItemType =
  (typeof IgnoreItemType)[keyof typeof IgnoreItemType];
export function chkIgnoreItemType(val: unknown): val is IgnoreItemType {
  return (
    TypeChk.isString(val) &&
    Object.values(IgnoreItemType).includes(val as IgnoreItemType)
  );
}

export const StorageId = Object.freeze({
  CurrentView: 'currentView',
  Shuffle: 'shuffle',
  Repeat: 'repeat',
  CurrentIndex: 'currentIndex',
  Mute: 'mute',
  Volume: 'volume',
  PlaybackOrder: 'playbackOrder',
  NowPlaying: 'nowPlaying',
  CurrentSongList: 'currentSongList',
  Locations: 'locations',
  DefaultLocation: 'defaultLocation',
  OnlyPlayLikes: 'onlyPlayLikes',
  NeverPlayHates: 'neverPlayHates',
  FullAlbumsOnly: 'fullAlbumsOnly',
  MinSongCount: 'minSongCount',
  LikedSongs: 'likedSongs',
  HatedSongs: 'hatedSongs',
  SortWithArticles: 'sortWithArticles',
  DownloadAlbumArtwork: 'downloadAlbumArtwork',
  DownloadArtistArtwork: 'downloadArtistArtwork',
  SaveAlbumArtworkWithMusic: 'saveAlbumArtworkWithMusic',
  AlbumCoverName: 'albumCoverName',
  TranscodingUpdate: 'getTranscodeUpdate',
  TranscodeSrcLocDir: 'transcodeSrcLocDir',
  TranscodeSrcLocPlaylist: 'transcodeSrcLocPlaylist',
  TranscodeSrcLocArtist: 'transcodeSrcLocArtist',
  TranscodeSrcLocAlbum: 'transcodeSrcLocAlbum',
  TranscodeDestLoc: 'transcodeDestLoc',
  TranscodeBitRate: 'transcodeBitRate',
});
export type StorageId = (typeof StorageId)[keyof typeof StorageId];
export function chkStorageId(val: unknown): val is StorageId {
  return (
    TypeChk.isString(val) && Object.values(StorageId).includes(val as StorageId)
  );
}

export const TranscodeFormatTargetName = Object.freeze({
  m4a: 'm4a',
  mp3: 'mp3',
  aac: 'aac',
});
export type TranscodeFormatTargetName =
  (typeof TranscodeFormatTargetName)[keyof typeof TranscodeFormatTargetName];
export function chkTranscodeFormatTargetName(
  val: unknown,
): val is TranscodeFormatTargetName {
  return (
    TypeChk.isString(val) &&
    Object.values(TranscodeFormatTargetName).includes(
      val as TranscodeFormatTargetName,
    )
  );
}

export const TranscodeSource = Object.freeze({
  Playlist: 'p',
  Artist: 'r',
  Album: 'l',
  Disk: 'd',
});
export type TranscodeSource =
  (typeof TranscodeSource)[keyof typeof TranscodeSource];
export function chkTranscodeSource(val: unknown): val is TranscodeSource {
  return (
    TypeChk.isString(val) &&
    Object.values(TranscodeSource).includes(val as TranscodeSource)
  );
}

export type TranscodeSourceLocation = {
  type: TranscodeSource;
  loc: string;
};
export const chkTranscodeSourceLocation: TypeChk.typecheck<TranscodeSourceLocation> =
  TypeChk.chkObjectOfType({
    type: chkTranscodeSource,
    loc: TypeChk.isString,
  });

export type FileFailure = {
  file: string;
  error: string;
};
export const chkFileFailure: TypeChk.typecheck<FileFailure> =
  TypeChk.chkObjectOfType({
    file: TypeChk.isString,
    error: TypeChk.isString,
  });

export type TranscodeState = {
  curStatus: string;
  filesTranscoded: string[];
  filesFound: number;
  filesPending: number;
  filesUntouched: number;
  filesFailed: FileFailure[];
  itemsRemoved: string[];
};
export const chkTranscodeState: TypeChk.typecheck<TranscodeState> =
  TypeChk.chkObjectOfType({
    curStatus: TypeChk.isString,
    filesTranscoded: TypeChk.chkArrayOf(TypeChk.isString),
    filesFound: chkIdlI32,
    filesPending: chkIdlI32,
    filesUntouched: chkIdlI32,
    filesFailed: TypeChk.chkArrayOf(chkFileFailure),
    itemsRemoved: TypeChk.chkArrayOf(TypeChk.isString),
  });

export type TranscodeInfo = {
  source: TranscodeSourceLocation;
  dest: string;
  artwork: boolean;
  mirror: boolean;
  format: TranscodeFormatTargetName;
  bitrate: number;
};
export const chkTranscodeInfo: TypeChk.typecheck<TranscodeInfo> =
  TypeChk.chkObjectOfType({
    source: chkTranscodeSourceLocation,
    dest: TypeChk.isString,
    artwork: TypeChk.isBoolean,
    mirror: TypeChk.isBoolean,
    format: chkTranscodeFormatTargetName,
    bitrate: chkIdlU16,
  });

export type SongKey = string;
export const chkSongKey = TypeChk.isString;

export type AlbumKey = string;
export const chkAlbumKey = TypeChk.isString;

export type ArtistKey = string;
export const chkArtistKey = TypeChk.isString;

export type MediaKey = string;
export const chkMediaKey = TypeChk.isString;

export type PlaylistName = string;
export const chkPlaylistName = TypeChk.isString;

export type Playlist = SongKey[];
export const chkPlaylist = TypeChk.chkArrayOf(chkSongKey);

export type Song = {
  key: SongKey;
  track: number;
  title: string;
  albumId: AlbumKey;
  artistIds: ArtistKey[];
  secondaryIds: ArtistKey[];
  variations: string[];
};
export const chkSong: TypeChk.typecheck<Song> = TypeChk.chkObjectOfType({
  key: chkSongKey,
  track: chkIdlI16,
  title: TypeChk.isString,
  albumId: chkAlbumKey,
  artistIds: TypeChk.chkArrayOf(chkArtistKey),
  secondaryIds: TypeChk.chkArrayOf(chkArtistKey),
  variations: TypeChk.chkArrayOf(TypeChk.isString),
});

export type SongWithPath = Song & {
  path: string;
};

export const VAType = Object.freeze({
  none: 'None',
  va: 'VA',
  ost: 'OST',
});
export type VAType = (typeof VAType)[keyof typeof VAType];
export function chkVAType(val: unknown): val is VAType {
  return TypeChk.isString(val) && Object.values(VAType).includes(val as VAType);
}

export type Artist = {
  key: ArtistKey;
  name: string;
  albums: AlbumKey[];
  songs: SongKey[];
};
export const chkArtist: TypeChk.typecheck<Artist> = TypeChk.chkObjectOfType({
  key: chkArtistKey,
  name: TypeChk.isString,
  albums: TypeChk.chkArrayOf(chkAlbumKey),
  songs: TypeChk.chkArrayOf(chkSongKey),
});

export type Album = {
  key: AlbumKey;
  year: number;
  title: string;
  vatype: VAType;
  primaryArtists: ArtistKey[];
  songs: SongKey[];
  diskNames: string[];
};
export const chkAlbum: TypeChk.typecheck<Album> = TypeChk.chkObjectOfType({
  key: chkAlbumKey,
  year: chkIdlI16,
  title: TypeChk.isString,
  vatype: chkVAType,
  primaryArtists: TypeChk.chkArrayOf(chkArtistKey),
  songs: TypeChk.chkArrayOf(chkSongKey),
  diskNames: TypeChk.chkArrayOf(TypeChk.isString),
});

export type MediaInfo = {
  general: Map<string, string>;
  audio: Map<string, string>;
};
export const chkMediaInfo: TypeChk.typecheck<MediaInfo> =
  TypeChk.chkObjectOfType({
    general: TypeChk.chkMapOf(TypeChk.isString, TypeChk.isString),
    audio: TypeChk.chkMapOf(TypeChk.isString, TypeChk.isString),
  });

export type SimpleMetadata = {
  artist: string;
  album: string;
  year: string;
  track: string;
  title: string;
  discNum: string;
  discName: string;
  compilation: VAType;
};
export const chkSimpleMetadata: TypeChk.typecheck<SimpleMetadata> =
  TypeChk.chkObjectOfType({
    artist: TypeChk.isString,
    album: TypeChk.isString,
    year: TypeChk.isString,
    track: TypeChk.isString,
    title: TypeChk.isString,
    discNum: TypeChk.isString,
    discName: TypeChk.isString,
    compilation: chkVAType,
  });

export type FullMetadata = {
  originalPath: string;
  artist: string[];
  album: string;
  year: number;
  track: number;
  title: string;
  vaType: VAType;
  moreArtists: string[];
  variations: string[];
  disk: number;
  diskName: string;
};
export const chkFullMetadata: TypeChk.typecheck<FullMetadata> =
  TypeChk.chkObjectOfType({
    originalPath: TypeChk.isString,
    artist: TypeChk.chkArrayOf(TypeChk.isString),
    album: TypeChk.isString,
    year: chkIdlI16,
    track: chkIdlI16,
    title: TypeChk.isString,
    vaType: chkVAType,
    moreArtists: TypeChk.chkArrayOf(TypeChk.isString),
    variations: TypeChk.chkArrayOf(TypeChk.isString),
    disk: chkIdlI16,
    diskName: TypeChk.isString,
  });

export type AudioFileRegexPattern = {
  compilation: VAType;
  rgx: string;
};
export const chkAudioFileRegexPattern: TypeChk.typecheck<AudioFileRegexPattern> =
  TypeChk.chkObjectOfType({
    compilation: chkVAType,
    rgx: TypeChk.isString,
  });

export type MimeData = {
  type: string;
  data: string;
};
export const chkMimeData: TypeChk.typecheck<MimeData> = TypeChk.chkObjectOfType(
  {
    type: TypeChk.isString,
    data: TypeChk.isString,
  },
);

export type MusicDatabase = {
  artists: Map<ArtistKey, Artist>;
  albums: Map<AlbumKey, Album>;
  songs: Map<SongKey, Song>;
  playlists: Map<string, Playlist>;
};
export const chkMusicDatabase: TypeChk.typecheck<MusicDatabase> =
  TypeChk.chkObjectOfType({
    artists: TypeChk.chkMapOf(chkArtistKey, chkArtist),
    albums: TypeChk.chkMapOf(chkAlbumKey, chkAlbum),
    songs: TypeChk.chkMapOf(chkSongKey, chkSong),
    playlists: TypeChk.chkMapOf(TypeChk.isString, chkPlaylist),
  });

export type FileFilterItem = {
  name: string;
  extensions: string[];
};
export const chkFileFilterItem: TypeChk.typecheck<FileFilterItem> =
  TypeChk.chkObjectOfType({
    name: TypeChk.isString,
    extensions: TypeChk.chkArrayOf(TypeChk.isString),
  });

export type OpenDialogOptions = {
  folder?: boolean;
  title?: string;
  defaultPath?: string;
  buttonLabel?: string;
  multiSelections?: boolean;
  filters?: FileFilterItem[];
};
export const chkOpenDialogOptions: TypeChk.typecheck<OpenDialogOptions> =
  TypeChk.chkObjectOfType({
    folder: chkOptional(TypeChk.isBoolean),
    title: chkOptional(TypeChk.isString),
    defaultPath: chkOptional(TypeChk.isString),
    buttonLabel: chkOptional(TypeChk.isString),
    multiSelections: chkOptional(TypeChk.isBoolean),
    filters: chkOptional(TypeChk.chkArrayOf(chkFileFilterItem)),
  });

export type SearchResults = {
  songs: SongKey[];
  artists: ArtistKey[];
  albums: AlbumKey[];
};
export const chkSearchResults: TypeChk.typecheck<SearchResults> =
  TypeChk.chkObjectOfType({
    songs: TypeChk.chkArrayOf(chkSongKey),
    artists: TypeChk.chkArrayOf(chkArtistKey),
    albums: TypeChk.chkArrayOf(chkAlbumKey),
  });

// End of generated code
